# -*- coding: utf-8 -*-
"""Titanic_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yh8I8YSfbinhxSsTAlrrdckoS4Duz3Lo
"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
import io
github_raw_loc = 'https://raw.githubusercontent.com/plotly/datasets/master/2014_apple_stock.csv' # Raw link should be public
df_titanic = pd.read_csv(io.BytesIO(uploaded['titanic_train.csv']))
# df_titanic_gender = pd.read_csv(io.BytesIO(uploaded['titanic_gender.csv']))

# df_titanic = pd.read_csv(github_raw_loc)

df_titanic.head()

print(df_titanic.columns.values)
print('\n','#'*40)
print(df_titanic.info())
print('\n','#'*40)
print(df_titanic.shape)

df_titanic.describe()

"""# Correlation matrix

Simple terms shows how close two variables are to having a linear relationship between one another

*   The higher the number the better.
*   Darker blocks have the highest co relation

Eg :- Pclass and fare represent a direct relationship

We will look into Pclass,age,gender,SibSp,Parch and try to check if assumption is correct or not

Lastly will check how fare corresponds to survival rate
"""

# import matplotlib as mpl
# mpl.rcParams['figure.dpi']= 75
# for higher quality

df_titanic['Gender_group'] = df_titanic['Sex'].apply(lambda x: 1 if(x == 'male') else 0)
plt.figure(figsize=(10,8))
sns.heatmap(df_titanic.corr(),annot = True)

"""# Survival rate based on gender


We conclude that females have a better survival rate than men
"""

data = df_titanic.groupby(['Sex','Survived']).size().reset_index(name='count')
# print(data.head())
sns.barplot(data=data,x='Sex',y='count',hue = 'Survived')
# sns.countplot(data=data,x='Sex',y='Survived',hue='0')

"""# Survival rate based on Age group

Over here first mean of age was calculated

Then we replaced age NAN values with mean of the values

Then we calulated out age group people between age 20 to 30 will get placed in group 2 and 30 to 40 in group 3 and so on.

Lastly, we generated graph with survival rate

Observation - 


*   Group 0 has the highest survival rate
*   Group 2 129 survived but 268 dint
*   Survival rate decreased with age
"""

# gender

def age_simple(age):  
  return int(age/10)

mean_age = df_titanic['Age'].median()
df_titanic['Age'] = df_titanic['Age'].fillna(value=mean_age)
#data = df_titanic['Age','Survived'].apply(age_simple,axis = 1)#.reset_index(name = 'group_age') #.groupby('group_age').size()
df_titanic['Age_group'] = df_titanic['Age'].apply(age_simple)
data = df_titanic.groupby(['Age_group','Survived']).size().reset_index(name = 'count')
# print(data)
plt.figure(figsize=(15,6))
sns.barplot(data=data,x='Age_group',y='count',hue='Survived')

"""# Survival rate based on P class

Observation - better(or lower) Pclass had better survival rate
"""

data = df_titanic.groupby(['Pclass','Survived']).size().reset_index(name='count')
plt.figure(figsize=(15,6))
sns.barplot(data=data,x='Pclass',y='count',hue='Survived')

"""# Survival rate based on family count


Creating a attribute survival rate which is sum of parent count + sibling count

*   People with atleast one family member had better survival rate
*   As the number of memebers grew survival rate lowered

We will use this attribute for modeling
"""

df_titanic['Family_members'] = df_titanic['Parch'] + df_titanic['SibSp']
data = df_titanic.groupby(['Family_members','Survived']).size().reset_index(name = 'count')
# print(data)
sns.barplot(data = data,x='Family_members',y='count',hue='Survived')

"""# Survival rate based on Fare price

*   Higher the price better the survival rate
"""

#data = df_titanic.groupby(['Fare','Survived']).size().reset_index(name = 'count').sort_values(by = 'Fare',ascending = False)

df_titanic['Fare_group'] = df_titanic['Fare'].apply(lambda x : int(x/50)) #.reset_index().groupby('Fare').size()
data = df_titanic.groupby(['Fare_group','Survived']).size().reset_index(name = 'count') #.sort_values(by = 'Fare_group',ascending = False)
sns.barplot(data = data,x='Fare_group',y='count',hue='Survived')

"""# Survival rate based on Embarked

*  C had better chance of survival
"""

# print(df_titanic['Embarked'].unique())
frq_emb = df_titanic['Embarked'].mode()[0]
df_titanic['Embarked'] = df_titanic['Embarked'].fillna(value = frq_emb)
data = df_titanic.groupby(['Embarked','Survived']).size().reset_index(name = 'count')
sns.barplot(data = data,x='Embarked',y='count',hue='Survived')

"""# Attributes that will be used of model

1.	PassengerId -> nope
2.	Survived -> y
3.	Pclass -> yes 
4.	Name -> nope
5.	Sex -> updated to Gender_group
6.	Age -> updated to Age_group
7.	SibSp -> updated to Family_members
8.	Parch -> updated to Family_members
9.	Ticket -> nope
10.	Fare -> nope
11.	Cabin -> nope
12.	Embarked -> yes
13.	Gender_group -> yes
14.	Age_group -> yes
15.	Family_members -> yes
16.	Fare_group -> yes
"""

df = df_titanic[['Pclass','Embarked','Gender_group','Age_group','Family_members','Fare_group','Survived']]
df.head(5)

nan_check = df.Fare_group.isnull()
nan_check[nan_check == True]

df.shape

"""# Prerequisite

Only need to take care of Embarked which has string value 
We will label encode then one hot encode
"""

from sklearn.preprocessing import LabelEncoder,OneHotEncoder,StandardScaler
import numpy as np
np.set_printoptions(threshold=np.inf)

l_encoder = LabelEncoder()
df['Embarked'] = l_encoder.fit_transform(df['Embarked'])
one_encode = OneHotEncoder(categorical_features=[1],sparse = False)
output = one_encode.fit_transform(df)[:,1:]
X = output[:,:-1]
y = output[:,-1:]
scaler = StandardScaler()
X = scaler.fit_transform(X)
print(output[:5,:])

"""# Splitting data into training and test"""

from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size = 0.2)

from sklearn.ensemble import RandomForestClassifier
model = RandomForestClassifier(n_estimators = 100)
model.fit(X_train,y_train)

score = model.score(X_test,y_test)
print(score)

from sklearn.metrics import confusion_matrix
y_pred = model.predict(X_test)
c_out = confusion_matrix(y_test, y_pred)
print(c_out)

